%\VignetteIndexEntry{segmentsSeq: Methylation locus identification}
%\VignettePackage{segmentSeq}

\documentclass[a4paper]{article}

%\usepackage{rotating}

\title{segmentSeq: methods for detecting methylation loci and differential methylation}
\author{Thomas J. Hardcastle}

\RequirePackage{/home/bioinf/tjh48/R/x86_64-pc-linux-gnu-library/3.3/BiocStyle/resources/tex/Bioconductor}

\AtBeginDocument{\bibliographystyle{/home/bioinf/tjh48/R/x86_64-pc-linux-gnu-library/3.3/BiocStyle/resources/tex/unsrturl}}

\usepackage{Sweave}
\begin{document}

\maketitle

\section{Introduction}

This vignette introduces analysis methods for data from high-throughput sequencing of bisulphite treated DNA to detect cytosine methylation. The \verb'segmentSeq' package was originally designed to detect siRNA loci \cite{Hardcastle:2011} and many of the methods developed for this can be used to detect loci of cytosine methylation from replicated (or unreplicated) sequencing data.

\section{Preparation}

Preparation of the segmentSeq package proceeds as in siRNA analysis. We begin by loading the \verb'segmentSeq' package.

\begin{Schunk}
\begin{Sinput}
>   library(segmentSeq)
\end{Sinput}
\end{Schunk}

Note that because the experiments that \verb'segmentSeq' is designed to analyse are usually massive, we should use (if possible) parallel processing as implemented by the \verb'parallel' package. If using this approach, we need to begin by define a \textsl{cluster}. The following command will use eight processors on a single machine; see the help page for 'makeCluster' for more information. If we don't want to parallelise, we can proceed anyway with a \verb'NULL' cluster. Results may be slightly different depending on whether or not a cluster is used owing to the non-deterministic elements of the method.

\begin{Schunk}
\begin{Sinput}
> if(require("parallel")) 
+ {
+     numCores <- min(8, detectCores())
+     cl <- makeCluster(numCores)
+ } else {
+     cl <- NULL
+ }
\end{Sinput}
\end{Schunk}

The \verb'segmentSeq' package is designed to read in output from the YAMA (Yet Another Methylome Aligner) program. This is a perl-based package using either bowtie or bowtie2 to align bisulphite treated reads (in an unbiased manner) to a reference and identify the number of times each cytosine is identified as methylated or unmethylated. Unlike most other aligners, YAMA does not require that reads that map to more than one location are discarded, instead it reports the number of alternate matches to the reference for each cytosine. This is then used by \verb'segmentSeq' to weight the observed number of methylated/un-methylated cytosines at a location. The files used here have been compressed to save space.

\begin{Schunk}
\begin{Sinput}
> datadir <- system.file("extdata", package = "segmentSeq")
> files <- c("short_18B_C24_C24_trim.fastq_CG_methCalls.gz",
+ "short_Sample_17A_trimmed.fastq_CG_methCalls.gz",
+ "short_13_C24_col_trim.fastq_CG_methCalls.gz",
+ "short_Sample_28_trimmed.fastq_CG_methCalls.gz")
> mD <- readMeths(files = files, dir = datadir,
+ libnames = c("A1", "A2", "B1", "B2"), replicates = c("A","A","B","B"),
+ nonconversion = c(0.004777, 0.005903, 0.016514, 0.006134))
\end{Sinput}
\end{Schunk}

We can begin by plotting the distribution of methylation for these samples. The distribution can be plotted for each sample individually, or as an average across multiple samples. We can also subtract one distribution from another to visualise patterns of differential methylation on the genome.

\begin{Schunk}
\begin{Sinput}
> par(mfrow = c(2,1))
> dists <- plotMethDistribution(mD, main = "Distributions of methylation", chr = "Chr1")
> plotMethDistribution(mD, 
+                      subtract = rowMeans(sapply(dists, function(x) x[,2])), 
+                      main = "Differences between distributions", chr = "Chr1")
\end{Sinput}
\end{Schunk}

%\begin{sidewaysfigure}[!ht]
\begin{figure}[!ht]
\begin{center}
\includegraphics{methylationAnalysis-figMethDist}
\caption{Distributions of methylation on the genome (first two million bases of chromosome 1.}
\label{fig:Seg}
\end{center}
\end{figure}
%\end{sidewaysfigure}


Next, we process this \verb'alignmentData' object to produce a \verb'segData' object. This \verb'segData' object contains a set of potential segments on the genome defined by the start and end points of regions of overlapping alignments in the \verb'alignmentData' object. It then evaluates the number of tags that hit in each of these segments.

\begin{Schunk}
\begin{Sinput}
> sD <- processAD(mD, cl = cl)
\end{Sinput}
\end{Schunk}


We can now construct a segment map from these potential segments.

\subsection*{Segmentation by heuristic Bayesian methods}

A fast method of segmentation can be achieved by assuming a binomial distribution on the data with an uninformative beta prior, and identifying those potential segments which have a sufficiently large posterior likelihood that the proportion of methylation exceeds some critical value. This value may be determined by examining the data using the 'thresholdFinder' function, or supplied manually.

\begin{Schunk}
\begin{Sinput}
> thresh <- thresholdFinder("beta", mD, cl = cl, bootstrap = 1)
> hS <- heuristicSeg(sD = sD, aD = mD, prop = thresh, cl = cl, gap = 100, getLikes = FALSE)
> hS
\end{Sinput}
\begin{Soutput}
GRanges object with 4335 ranges and 0 metadata columns:
         seqnames             ranges strand
            <Rle>          <IRanges>  <Rle>
     [1]     Chr1         [108, 115]      *
     [2]     Chr1         [161, 310]      *
     [3]     Chr1         [500, 500]      *
     [4]     Chr1         [511, 511]      *
     [5]     Chr1         [642, 650]      *
     ...      ...                ...    ...
  [4331]     Chr1 [1988245, 1988245]      *
  [4332]     Chr1 [1990160, 1990160]      *
  [4333]     Chr1 [1990186, 1990298]      *
  [4334]     Chr1 [1993149, 1993149]      *
  [4335]     Chr1 [1993335, 1993335]      *
  -------
  seqinfo: 1 sequence from an unspecified genome; no seqlengths
An object of class "lociData"
4335 rows and 4 columns

Slot "replicates"
A A B B
Slot "groups":
list()

Slot "data":
     [,1]  [,2]  [,3] [,4]
[1,] 64:12 14:6  31:9 1:1 
[2,] 39:2  38:8  32:5 6:0 
[3,] 10:0  8:3   8:1  2:1 
[4,] 10:0  9:2   8:2  5:0 
[5,] 55:18 75:31 36:9 10:2
4330 more rows...

Slot "annotation":
data frame with 0 columns and 4335 rows

Slot "locLikelihoods" (stored on log scale):
Matrix with  4335  rows.
       A   B
1      1   1
2      1   1
3      1   1
4      1   1
5      1   1
...  ... ...
4331   1   0
4332   0   1
4333   0   1
4334   1   1
4335   1   0

Expected number of loci in each replicate group
   A    B 
3230 3112 
\end{Soutput}
\end{Schunk}



Within a methylation locus, it is not uncommon to find completely unmethylated cytosines. If the coverage of these cytosines is too high, it is possible that these will cause the locus to be split into two or more fragments. The \verb'mergeMethSegs' function can be used to overcome this splitting by merging loci with identical patterns of expression that are not separated by too great a gap. Merging in this manner is optional, but recommended.

\begin{Schunk}
\begin{Sinput}
> hS <- mergeMethSegs(hS, mD, gap = 5000, cl = cl)
\end{Sinput}
\end{Schunk}

We can then estimate posterior likelihoods on the defined loci by applying empirical Bayesian methods. These will not change the locus definition, but will assign likelihoods that the identified loci represent a true methylation locus in each replicate group.

\begin{Schunk}
\begin{Sinput}
> hSL <- lociLikelihoods(hS, mD, cl = cl)
\end{Sinput}
\begin{Soutput}
......
\end{Soutput}
\end{Schunk}

%\subsection*{Segmentation by empirical Bayesian Methods}

%Classification of the potential segments can also be carried out using empirical Bayesian methods. These are extremely computationally intensive, but allow %biological variation within replicates to be more accurately modelled, thus providing an improved identification of methylation loci. 

%<<>>=
%eBS <- classifySeg(sD, hS, mD, cl = cl)
%@ 

\subsection*{Visualising loci}

By one of these methods, we finally acquire an annotated \verb'methData' object, with the annotations describing the co-ordinates of each segment.

We can use this \verb'methData' object, in combination with the \verb'alignmentMeth' object, to plot the segmented genome.

\begin{Schunk}
\begin{Sinput}
> plotMeth(mD, hSL, chr = "Chr1", limits = c(1, 50000), cap = 10)
\end{Sinput}
\end{Schunk}

%\begin{sidewaysfigure}[!ht]
\begin{figure}[!ht]
\begin{center}
\includegraphics{methylationAnalysis-figplotMeth}
\caption{Methylation and identified loci on the first ten thousand bases of chromosome 1.}
\label{fig:plotMeth}
\end{center}
\end{figure}
%\end{sidewaysfigure}



\subsection*{Differential Methylation analysis}

We can also examine the \verb'methData' object for differentially methylated regions using the beta-binomial methods \cite{Hardcastle:2013} implemented in \verb'baySeq'. We first define a group structure on the data.

\begin{Schunk}
\begin{Sinput}
> groups(hSL) <- list(NDE = c(1,1,1,1), DE = c("A", "A", "B", "B"))
\end{Sinput}
\end{Schunk}

The methObservables function pre-calculates a set of data to improve the speed of prior and posterior estimation (at some minor memory cost).
\begin{Schunk}
\begin{Sinput}
> hSL <- methObservables(hSL)
\end{Sinput}
\end{Schunk}

The density function used here is a composite of the beta-binomial and a binomial distribution that accounts for the reported non-conversion rates.
\begin{Schunk}
\begin{Sinput}
> densityFunction(hSL) <- bbNCDist
\end{Sinput}
\end{Schunk}

We can then determine a prior distribution on the parameters of the model for the data.
\begin{Schunk}
\begin{Sinput}
> hSL <- getPriors(hSL, cl = cl)
\end{Sinput}
\end{Schunk}

We can then find the posterior likelihoods of the models defined in the groups structure.

\begin{Schunk}
\begin{Sinput}
> hSL <- getLikelihoods(hSL, cl = cl)
\end{Sinput}
\begin{Soutput}
.
\end{Soutput}
\end{Schunk}

We can then retrieve the data for the top differentially methylated regions.

\begin{Schunk}
\begin{Sinput}
> topCounts(hSL, "DE")
\end{Sinput}
\begin{Soutput}
   seqnames   start     end width strand    A.1    A.2    B.1  B.2 Likelihood ordering
1      Chr1 1439804 1440002   199      *  1:239  0:119 102:56 11:5  0.9996927      B>A
2      Chr1  774658  774937   280      *  0:172   0:90  38:16 14:7  0.9996898      B>A
3      Chr1 1192725 1192730     6      *   37:4   15:2   0:55  0:8  0.9996212      A>B
4      Chr1  888560  888590    31      * 423:90 217:56   1:37  0:7  0.9995778      A>B
5      Chr1   25580   25583     4      *   20:2   49:3   0:58  0:3  0.9995778      A>B
6      Chr1 1733868 1733987   120      *  0:104  0:150  76:62 11:7  0.9995657      B>A
7      Chr1  297002  297016    15      *  60:23  48:19   0:48  0:9  0.9995431      A>B
8      Chr1  235528  235557    30      *  2:233   0:92  71:38  9:5  0.9995350      B>A
9      Chr1  889432  889508    77      *  2:204  0:131  75:24  9:3  0.9995298      B>A
10     Chr1 1686726 1686728     3      *   27:2   24:1   0:30  0:5  0.9995071      A>B
         FDR.DE      FWER.DE
1  0.0003073375 0.0003073375
2  0.0003087705 0.0006174456
3  0.0003321168 0.0009960213
4  0.0003546306 0.0014177728
5  0.0003681489 0.0018393961
6  0.0003791688 0.0022728655
7  0.0003902764 0.0027287493
8  0.0003996222 0.0031925228
9  0.0004074663 0.0036612405
10 0.0004160088 0.0041523274
\end{Soutput}
\end{Schunk}

Finally, to be a good citizen, we stop the cluster we started earlier:

\begin{Schunk}
\begin{Sinput}
> if(!is.null(cl))
+     stopCluster(cl)
\end{Sinput}
\end{Schunk}


\section*{Session Info}

\begin{Schunk}
\begin{Sinput}
> sessionInfo()
\end{Sinput}
\begin{Soutput}
R version 3.3.2 (2016-10-31)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Debian GNU/Linux 8 (jessie)

locale:
 [1] LC_CTYPE=en_GB.UTF-8       LC_NUMERIC=C               LC_TIME=en_GB.UTF-8       
 [4] LC_COLLATE=en_GB.UTF-8     LC_MONETARY=en_GB.UTF-8    LC_MESSAGES=en_GB.UTF-8   
 [7] LC_PAPER=en_GB.UTF-8       LC_NAME=C                  LC_ADDRESS=C              
[10] LC_TELEPHONE=C             LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] parallel  stats4    stats     graphics  grDevices utils     datasets  methods  
[9] base     

other attached packages:
 [1] segmentSeq_2.9.5           ShortRead_1.32.0           GenomicAlignments_1.10.0  
 [4] SummarizedExperiment_1.4.0 Biobase_2.34.0             Rsamtools_1.26.1          
 [7] Biostrings_2.42.0          XVector_0.14.0             BiocParallel_1.8.1        
[10] baySeq_2.7.10              abind_1.4-5                GenomicRanges_1.26.1      
[13] GenomeInfoDb_1.10.1        IRanges_2.8.1              S4Vectors_0.12.0          
[16] BiocGenerics_0.20.0       

loaded via a namespace (and not attached):
 [1] edgeR_3.16.1        zlibbioc_1.20.0     lattice_0.20-34     hwriter_1.3.2      
 [5] tools_3.3.2         grid_3.3.2          latticeExtra_0.6-28 Matrix_1.2-7.1     
 [9] RColorBrewer_1.1-2  bitops_1.0-6        limma_3.30.4        compiler_3.3.2     
[13] locfit_1.5-9.1      BiocStyle_2.2.0    
\end{Soutput}
\end{Schunk}


\begin{thebibliography}{99}
\bibitem{Hardcastle:2011} Thomas J. Hardcastle and Krystyna A. Kelly and David C. Baulcombe. \textsl{Identifying small RNA loci from high-throughput sequencing data.} Bioinformatics (2012).
\bibitem{Hardcastle:2013} Thomas J. Hardcastle and Krystyna A. Kelly. \textsl{Empirical Bayesian analysis of paired high-throughput sequencing data with a beta-binomial distribution.} BMC Bioinformatics (2013).

\end{thebibliography}

\end{document}
